#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <map>
#include <unordered_map>
#include <limits.h>

const std::string ALPHABET    = ".ALPHABET";
const std::string STATES      = ".STATES";
const std::string TRANSITIONS = ".TRANSITIONS";
const std::string INPUT       = ".INPUT";
const std::string EMPTY       = ".EMPTY";

unsigned char wlp4_dfa[] = {
  0x2e, 0x41, 0x4c, 0x50, 0x48, 0x41, 0x42, 0x45, 0x54, 0x0a, 0x30, 0x2d,
  0x39, 0x20, 0x61, 0x2d, 0x7a, 0x20, 0x41, 0x2d, 0x5a, 0x20, 0x2c, 0x20,
  0x3b, 0x20, 0x21, 0x20, 0x3c, 0x20, 0x3e, 0x20, 0x2b, 0x20, 0x3d, 0x20,
  0x2d, 0x20, 0x2f, 0x20, 0x25, 0x20, 0x7b, 0x20, 0x7d, 0x20, 0x2a, 0x20,
  0x26, 0x20, 0x5b, 0x20, 0x5d, 0x20, 0x28, 0x20, 0x29, 0x0a, 0x2e, 0x53,
  0x54, 0x41, 0x54, 0x45, 0x53, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x0a,
  0x4e, 0x55, 0x4d, 0x21, 0x0a, 0x49, 0x44, 0x21, 0x0a, 0x4e, 0x55, 0x4d,
  0x21, 0x0a, 0x4c, 0x50, 0x41, 0x52, 0x45, 0x4e, 0x21, 0x0a, 0x52, 0x50,
  0x41, 0x52, 0x45, 0x4e, 0x21, 0x0a, 0x4c, 0x42, 0x52, 0x41, 0x43, 0x45,
  0x21, 0x0a, 0x52, 0x42, 0x52, 0x41, 0x43, 0x45, 0x21, 0x0a, 0x42, 0x45,
  0x43, 0x4f, 0x4d, 0x45, 0x53, 0x21, 0x0a, 0x49, 0x4e, 0x54, 0x21, 0x0a,
  0x45, 0x51, 0x21, 0x0a, 0x4e, 0x45, 0x21, 0x0a, 0x4c, 0x54, 0x21, 0x0a,
  0x47, 0x54, 0x21, 0x0a, 0x4c, 0x45, 0x21, 0x0a, 0x47, 0x45, 0x21, 0x0a,
  0x50, 0x4c, 0x55, 0x53, 0x21, 0x0a, 0x4d, 0x49, 0x4e, 0x55, 0x53, 0x21,
  0x0a, 0x53, 0x54, 0x41, 0x52, 0x21, 0x0a, 0x53, 0x4c, 0x41, 0x53, 0x48,
  0x21, 0x0a, 0x43, 0x4f, 0x4d, 0x4d, 0x45, 0x4e, 0x54, 0x21, 0x0a, 0x50,
  0x43, 0x54, 0x21, 0x0a, 0x43, 0x4f, 0x4d, 0x4d, 0x41, 0x21, 0x0a, 0x53,
  0x45, 0x4d, 0x49, 0x21, 0x0a, 0x4c, 0x42, 0x52, 0x41, 0x43, 0x4b, 0x21,
  0x0a, 0x52, 0x42, 0x52, 0x41, 0x43, 0x4b, 0x21, 0x0a, 0x41, 0x4d, 0x50,
  0x21, 0x0a, 0x4e, 0x55, 0x4c, 0x4c, 0x21, 0x0a, 0x5a, 0x45, 0x52, 0x4f,
  0x21, 0x0a, 0x6e, 0x65, 0x31, 0x0a, 0x2e, 0x54, 0x52, 0x41, 0x4e, 0x53,
  0x49, 0x54, 0x49, 0x4f, 0x4e, 0x53, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74,
  0x20, 0x30, 0x20, 0x5a, 0x45, 0x52, 0x4f, 0x0a, 0x73, 0x74, 0x61, 0x72,
  0x74, 0x20, 0x3d, 0x20, 0x42, 0x45, 0x43, 0x4f, 0x4d, 0x45, 0x53, 0x0a,
  0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x31, 0x2d, 0x39, 0x20, 0x4e, 0x55,
  0x4d, 0x20, 0x0a, 0x4e, 0x55, 0x4d, 0x20, 0x30, 0x2d, 0x39, 0x20, 0x4e,
  0x55, 0x4d, 0x20, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x61, 0x2d,
  0x7a, 0x20, 0x49, 0x44, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x41,
  0x2d, 0x5a, 0x20, 0x49, 0x44, 0x20, 0x0a, 0x49, 0x44, 0x20, 0x30, 0x2d,
  0x39, 0x20, 0x49, 0x44, 0x0a, 0x49, 0x44, 0x20, 0x61, 0x2d, 0x7a, 0x20,
  0x49, 0x44, 0x0a, 0x49, 0x44, 0x20, 0x41, 0x2d, 0x5a, 0x20, 0x49, 0x44,
  0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x2b, 0x20, 0x50, 0x4c, 0x55,
  0x53, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x2d, 0x20, 0x4d, 0x49,
  0x4e, 0x55, 0x53, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x2a, 0x20,
  0x53, 0x54, 0x41, 0x52, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x2f,
  0x20, 0x53, 0x4c, 0x41, 0x53, 0x48, 0x0a, 0x53, 0x4c, 0x41, 0x53, 0x48,
  0x20, 0x2f, 0x20, 0x43, 0x4f, 0x4d, 0x4d, 0x45, 0x4e, 0x54, 0x0a, 0x42,
  0x45, 0x43, 0x4f, 0x4d, 0x45, 0x53, 0x20, 0x3d, 0x20, 0x45, 0x51, 0x0a,
  0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x21, 0x20, 0x6e, 0x65, 0x31, 0x0a,
  0x6e, 0x65, 0x31, 0x20, 0x3d, 0x20, 0x4e, 0x45, 0x0a, 0x73, 0x74, 0x61,
  0x72, 0x74, 0x20, 0x3c, 0x20, 0x4c, 0x54, 0x0a, 0x4c, 0x54, 0x20, 0x3d,
  0x20, 0x4c, 0x45, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x3e, 0x20,
  0x47, 0x54, 0x0a, 0x47, 0x54, 0x20, 0x3d, 0x20, 0x47, 0x45, 0x0a, 0x73,
  0x74, 0x61, 0x72, 0x74, 0x20, 0x25, 0x20, 0x50, 0x43, 0x54, 0x0a, 0x73,
  0x74, 0x61, 0x72, 0x74, 0x20, 0x2c, 0x20, 0x43, 0x4f, 0x4d, 0x4d, 0x41,
  0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x3b, 0x20, 0x53, 0x45, 0x4d,
  0x49, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x26, 0x20, 0x41, 0x4d,
  0x50, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x5b, 0x20, 0x4c, 0x42,
  0x52, 0x41, 0x43, 0x4b, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x5d,
  0x20, 0x52, 0x42, 0x52, 0x41, 0x43, 0x4b, 0x0a, 0x73, 0x74, 0x61, 0x72,
  0x74, 0x20, 0x28, 0x20, 0x4c, 0x50, 0x41, 0x52, 0x45, 0x4e, 0x0a, 0x73,
  0x74, 0x61, 0x72, 0x74, 0x20, 0x29, 0x20, 0x52, 0x50, 0x41, 0x52, 0x45,
  0x4e, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x7b, 0x20, 0x4c, 0x42,
  0x52, 0x41, 0x43, 0x45, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x7d,
  0x20, 0x52, 0x42, 0x52, 0x41, 0x43, 0x45, 0x0a, 0x2e, 0x49, 0x4e, 0x50,
  0x55, 0x54, 0x0a
};
unsigned int wlp4_dfa_len = 663;








std::string parse_descriptor(std::string state){
  if (state == "REG1" || state == "REG2"){
    return "REG";
  } else if (state == "ZERO-DEC") {
    return "DEC";
  }
  return state;
}

bool isChar(std::string s) {
  return s.length() == 1;
}
bool isRange(std::string s) {
  return s.length() == 3 && s[1] == '-';
}

void printDirectory(const std::map<std::string, std::map<char, std::string>>& directory) {
  std::cout << "\n--- Transition Directory ---\n";
  for (const auto& [fromState, transitions] : directory) {
    for (const auto& [symbol, toState] : transitions) {
      std::cout << "  " << fromState 
                << "   " << symbol 
                << "    " << toState << "\n"<<std::endl;
    }
  }
}

void printState(const std::map<std::string, bool> state){
    for (const auto & [fromState, accepting]: state){
        std::cout<<fromState<< "  "<<accepting<<std::endl;
    }
}

// need to edit this such that it's reading in from a file? 
void tokenize(){
  std::string s;
  std::string initial_string;

  std::map<std::string,std::map<char, std::string>> directory;  // transitions 
  std::map<std::string, bool> states; // accepting states 
  std::vector<std::string> alphabet; // alphabet 
  
  std::string foo((char *) wlp4_dfa, wlp4_dfa_len);
  std::stringstream in(foo);

  std::getline(in, s); // Alphabet section (skip header)
  // Read characters or ranges separated by whitespace
  while(in >> s) {
    if (s == STATES) { 
      break; 
    } else {
      if (isChar(s)) {
        //// Variable 's[0]' is an alphabet symbol
        alphabet.push_back(s); 

      } else if (isRange(s)) {
        for(char c = s[0]; c <= s[2]; ++c) {
          //// Variable 'c' is an alphabet symbol
          alphabet.push_back(std::string(1, c)); 
        }
      } 
    }
  }

  std::getline(in, s); // States section (skip header)
  // Read states separated by whitespace
  while(in >> s) {
    if (s == TRANSITIONS) { 
      break; 
    } else {
      static bool initial = true;
      bool accepting = false;
      if (s.back() == '!' && !isChar(s)) {
        accepting = true;
        s.pop_back();
      }
      //// Variable 's' contains the name of a state
      if (initial) {
        //// The state is initial
        initial = false;
        initial_string = s; 
        states[initial_string] = accepting; 
      }
      if (accepting) {
        //// The state is accepting
        states[s] = accepting; 
      }
    }
  }

  std::getline(in, s); // Transitions section (skip header)
  // Read transitions line-by-line
  while(std::getline(in, s)) {
    if (s == INPUT) { 
      // Note: Since we're reading line by line, once we encounter the
      // input header, we will already be on the line after the header
      break; 
    } else {
      std::string fromState, symbols, toState;
      std::istringstream line(s);
      std::vector<std::string> lineVec;
      while(line >> s) {
        lineVec.push_back(s);
      }
      fromState = lineVec.front();
      toState = lineVec.back();
      for(int i = 1; i < lineVec.size()-1; ++i) {
        std::string s = lineVec[i];
        if (isChar(s)) {
          symbols += s;
        } else if (isRange(s)) {
          for(char c = s[0]; c <= s[2]; ++c) {
            symbols += c;
          }
        }
      }
      for ( char c : symbols ) {
        //// There is a transition from 'fromState' to 'toState' on 'c'
        directory[fromState][c]= toState; 
      }
    }
  }

    // over here ##
    std::unordered_map<std::string, std::string> keyword_map = {
        {"wain", "WAIN"},
        {"int", "INT"},
        {"if", "IF"},
        {"else", "ELSE"},
        {"while", "WHILE"},
        {"println", "PRINTLN"},
        {"putchar", "PUTCHAR"},
        {"getchar", "GETCHAR"},
        {"return", "RETURN"},
        {"NULL", "NULL"},
        {"new", "NEW"},
        {"delete", "DELETE"},
        {"0","NUM"}
    };

  // directory["start"][' '] = [".SPACE"];
  // states[".SPACE"] = true; 
  // alphabet.push_back(" "); 
  // printDirectory(directory);

  std::string asm_line; 
  in.clear();
  // Input section (already skipped header)
  while(std::getline(std::cin,asm_line)) {

      std::stringstream ss(asm_line);  // wrap the line in a stream
      std::string token;
      bool valid = true; 

    while(ss>>token){
      std::string s = token;
      std::string currentState = initial_string;
      std::string tokenReadsoFar; 
      bool accepted = true; 
      bool comment_hit = false; 
      for (int i = 0; i < s.length(); ++i) {
          // read in the first string 
        if (comment_hit){
            break; 
        }
        if (directory[currentState].count(s[i])) {
          tokenReadsoFar += s[i];
          currentState = directory[currentState][s[i]];
        } else {
          if (states[currentState]){// when we hit a token that's no longer in an accepting state 
              std::string descriptor = parse_descriptor(currentState); 
              if (descriptor == "NUM"){

                if (tokenReadsoFar.size()>10){
                  valid = false; 
                  accepted = false; 
                  break; 
                }
                long long int big_boy= std::stoll(tokenReadsoFar); 
                //std::cout<<"NUM REACHED 1" <<std::endl;
                if (big_boy > INT_MAX){
                  valid = false; 
                  accepted = false; 
                  break; 
                }
              }
              if (keyword_map.count(tokenReadsoFar)){
                descriptor = keyword_map[tokenReadsoFar]; 
              }
              if (descriptor == "COMMENT"){
                tokenReadsoFar = "";
                comment_hit = true; 
                break;
              }
              std::cout<<descriptor<< " "<<tokenReadsoFar<<std::endl; 
              tokenReadsoFar=""; // reset the tokens 
              currentState = initial_string; 
              accepted = true;
              --i; 
          } else {
            break; 
          }
          continue; 
        }
      }
      if (comment_hit){
        break;
      }
      else if (accepted && states[currentState]){
        std::string descriptor = parse_descriptor(currentState); 
        if (descriptor == "COMMENT"){
            break; 
        }
        if (descriptor == "NUM"){
          //std::cout<<"NUM REACHED 1" <<std::endl;

          if (tokenReadsoFar.size()>10){
            valid = false; 
            accepted = false; 
            break; 
          }
          long long int big_boy= std::stoll(tokenReadsoFar); 
          if (big_boy > INT_MAX){
            std::cerr<<"ERROR!"<<" Current State: " <<currentState<<"  "<< tokenReadsoFar <<std::endl;
            valid = false; 
            break; 
          }
        }
        if (keyword_map.count(tokenReadsoFar)){
                descriptor = keyword_map[tokenReadsoFar]; 
        }

        std::cout<<descriptor<< " "<<tokenReadsoFar<<std::endl;  
      } else {
        std::cerr<<"ERROR!"<<" Current State: " <<currentState<<"  "<< tokenReadsoFar <<std::endl;
        valid = false; 
        break;
      }

    }
    if (!valid){
      break;
    }
  }
}

int main() {
    tokenize();
}
